import { ethers, deployments } from "hardhat";
import { expect } from "chai";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { getPoolAddressesProvider } from "@aave/deploy-v3";

describe("AaveVault", function () {
  async function setupContracts() {
    // Set the MARKET_NAME env var
    process.env.MARKET_NAME = "Aave";

    // Deploy Aave V3 contracts before running tests, some error here
    await deployments.fixture(["market", "periphery-post"]);

    const poolAddressesProvider = await getPoolAddressesProvider();
    const poolAddress = await poolAddressesProvider.getPool();
    const poolDataProviderAddress =
      await poolAddressesProvider.getPoolDataProvider();

    const [owner, addr1] = await ethers.getSigners();

    const MockDAI = await ethers.getContractFactory("MockDAI");
    const daiToken = await MockDAI.deploy();
    await daiToken.deployed();

    const AaveVault = await ethers.getContractFactory("AaveVault");
    //set gas limit for deployment
    /*const aaveVault = await AaveVault.deploy(
      poolAddress,
      poolDataProviderAddress,
      daiTokenAddress
    );*/
    const aaveVault = await AaveVault.deploy(
      poolAddress,
      poolDataProviderAddress,
      daiToken.address,
      { gasLimit: 1000000 }
    );

    await aaveVault.deployed();

    const pool = await ethers.getContractAt("IPool", poolAddress);
    const poolDataProvider = await ethers.getContractAt(
      "IPoolDataProvider",
      poolDataProviderAddress
    );
    //mint 100 dai to owner
    //await daiToken.connect(owner).mint(ethers.utils.parseEther("100"))
    //print owner balance

    return { owner, addr1, pool, poolDataProvider, daiToken, aaveVault };
  }

  it("should deposit DAI into the vault", async function () {
    const { owner, addr1, daiToken, aaveVault } = await loadFixture(
      setupContracts
    );
    //expect(await daiToken.balanceOf(owner.address)).to.be.gt(1);

    /*const depositAmount = ethers.utils.parseEther("1");

    // Transfer some DAI tokens to addr1 for testing purposes
    await daiToken.connect(owner).transfer(addr1.address, depositAmount);
    await daiToken.connect(addr1).approve(aaveVault.address, depositAmount);

    // Deposit DAI from addr1 to the AaveVault
    await aaveVault.connect(addr1).deposit(depositAmount);

    const aDaiBalance = await aaveVault.getADaiBalance();
    expect(aDaiBalance).to.be.gt(0);*/
  });

  /*it("should withdraw DAI from the vault", async function () {
    const { owner, daiToken, aaveVault } = await loadFixture(setupContracts);
    const depositAmount = ethers.utils.parseEther("1");
    const withdrawAmount = ethers.utils.parseEther("0.5");

    await daiToken.connect(owner).approve(aaveVault.address, depositAmount);
    await aaveVault.deposit(depositAmount);
    await aaveVault.withdraw(withdrawAmount);

    const ownerDaiBalance = await daiToken.balanceOf(owner.address);
    expect(ownerDaiBalance).to.be.gte(withdrawAmount);
  });

  it("should redeem aDAI for DAI", async function () {
    const { owner, daiToken, aaveVault } = await loadFixture(setupContracts);
    const depositAmount = ethers.utils.parseEther("1");

    await daiToken.connect(owner).approve(aaveVault.address, depositAmount);
    await aaveVault.deposit(depositAmount);
    await aaveVault.redeem();

    const ownerDaiBalance = await daiToken.balanceOf(owner.address);
    expect(ownerDaiBalance).to.be.gt(depositAmount);
  });

  it("should not allow non-owner to withdraw or redeem", async function () {
    const { owner, addr1, daiToken, aaveVault } = await loadFixture(
      setupContracts
    );

    const depositAmount = ethers.utils.parseEther("1");
    const withdrawAmount = ethers.utils.parseEther("0.5");

    await daiToken.connect(owner).approve(aaveVault.address, depositAmount);
    await aaveVault.deposit(depositAmount);

    await expect(
      aaveVault.connect(addr1).withdraw(withdrawAmount)
    ).to.be.revertedWith("Only the owner can withdraw.");
    await expect(aaveVault.connect(addr1).redeem()).to.be.revertedWith(
      "Only the owner can redeem a DAI."
    );
  });

  it("should not allow depositing more than the user's DAI balance", async function () {
    const { owner, addr1, daiToken, aaveVault } = await loadFixture(
      setupContracts
    );
    const depositAmount = ethers.utils.parseEther("1");
    const excessiveAmount = ethers.utils.parseEther("2");
    // Transfer some DAI tokens to addr1 for testing purposes
    await daiToken.connect(owner).transfer(addr1.address, depositAmount);
    await daiToken.connect(addr1).approve(aaveVault.address, excessiveAmount);

    // Attempt to deposit more DAI than addr1 has
    await expect(aaveVault.connect(addr1).deposit(excessiveAmount)).to.be
      .reverted;
  });*/
});
